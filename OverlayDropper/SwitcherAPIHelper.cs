/* -LICENSE-START-
** Copyright (c) 2011 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

using System;

using System.Reflection;
using System.Runtime.InteropServices;

namespace SwitcherPanelCSharp
{
    class SwitcherAPIHelper
    {
        /// <summary>
        /// This helper method is used for calling the "CreateIterator" method on various Switcher API
        /// objects. The CreateIterator pattern is a common pattern used throughout the Switcher API in
        /// order to get children objects (For example, getting a Mix Effect block iterator from a Switcher
        /// or getting a Key iterator from a Mix Effect bock).
        /// The CreateIterator pattern works well in native COM, but isn't so convinent in C#. You must
        /// parse in the IID of the interface you wish to get (as a reference), as well as an IntPtr
        /// to get the actual interface. The IntPtr must then be converted to the interface you are
        /// interested in (via COMs IUnknown class).
        /// </summary>
        /// <typeparam name="A">The type of the parent interface that implements "CreateIterator"</typeparam>
        /// <typeparam name="B">The type of the iterator interface</typeparam>
        /// <param name="baseClass">A reference to the parent class</param>
        /// <param name="output">An out reference to the new iterator object</param>
        /// <returns>True on success</returns>
        public static bool CreateIterator<A, B>(A baseClass, out B output)
        {
            // Get the guid of the type we are requesting
            Guid guid = typeof(B).GUID;

            // Get the method called "CreateIterator" on the base class.
            // We use runtime reflection to get the CreateIterator method, as C# generics don't
            // really allow us to call this directly: the base classes that implement CreateIterator do
            // not come from a common ancestry.
            MethodInfo method = typeof(A).GetMethod("CreateIterator",
                new Type[] { typeof(Guid).MakeByRefType(), typeof(IntPtr).MakeByRefType() });

            if (method == null)
            {
                output = default(B);
                return false;
            }

            object[] parameters = new object[] { guid, null };
            method.Invoke(baseClass, parameters);

            // Get the IUknown from the pointer, and cast (QueryInterface) to our required type.
            output = (B)Marshal.GetObjectForIUnknown((IntPtr)parameters[1]);

            return true;
        }
    }
}
